---
sidebar_position: 1
pagination_next: get-started/index
---

# 🔎 Intro

<span class="badge badge--secondary margin-bottom--md">OVERVIEW-ORIENTED</span>

![feature-sliced-banner](/img/banner.jpg)

FeatureSliced is an architectural design methodology for *frontend projects*. It aims to **divide an application according to business logic and scopes of responsibility.**

- Provides [**explicitness, controllability and adaptability**][refs-arch-req] of architecture
- Based on [**time-tested**][refs-motivation-why] design practices and concepts
    > `SOLID`, `GRASP`, `DDD`, `Separation of Concerns`, `Vertical Slices`, `Public API`, `Isolation`
- Suggests dividing the project according to [**business units**][ext-ubiq-lang]

:::note
The methodology is not tied to a specific tech stack and is applicable *to any frontend projects* in general.

But the current version is based on and provides examples for `JavaScript` + `React` stack.
:::

## Basics

![schema-themed--scheme](/img/visual_schema.jpg)

> More details: ["Concepts, Abstractions, Structure"][refs-basics]

## Motivation

Usually, approaches to building the frontend architecture from project to project are [re-invented from scratch][refs-motivation], thereby adding ["project knowledge"][refs-knowledge]

> Despite the fact that the specifics of frontend projects do not differ so much

At the same time, incorrectly made decisions often lead [to problems of scalability of the project and the team][refs-arch-problems].

And therefore, instead of inventing and documenting it every time, it is better to **summarize the experience and form a working, battle-tested and documented methodology** for designing the frontend architecture.

*Yes, there are many practices and patterns (`SOLID`, `GRASP`, `DDD`, ...)*

*But for the frontend [it is highly difficult to find][refs-motivation] well-established and specific approaches*

## Overview

The methodology is designed to **simplify and standardize the decomposition of logic for large and long-lived projects.**

To do this, it introduces a number of [concepts][refs-concepts] and [abstractions][refs-splitting], on which the architecture *can be based* from project to project - from here we get *a number of advantages*

:::info

[Module][refs-module] - the structural unit of the project (file / directory)

:::

### Explicit business logic

Modules are distributed according to [scope of influence, business responsibility and technical purpose][refs-splitting]

Thanks to this, *the architecture is standardized and becomes easier to read*

### Adaptation to new conditions

Each component of the architecture has its own purpose and does not affect the others

Thanks to this *it is possible to independently modify the functionality of the application to meet new requirements without unforeseen consequences*

### Technical debt and refactoring

Each module is independent and self-sufficient

Thanks to this *you can rewrite it from scratch without unexpected side effects*

### Scaling the project and the team

The increase in functionality leads to significantly less complexity of the project, since all the logic is distributed deterministically and in isolation

Thanks to this *it is easy to add and onboard new people to the team, as well as expand the functionality of the project*

### Controlled reuse of logic

Each module has its own limitations and recommendations for reuse according to [its layer][refs-splitting--layers]

Thanks to this, *a balance is maintained between compliance with the `DRY` principle and the ability to customize the module logic without overhead overrides*

## What's next?

import Row from "@site/src/shared/ui/row/tmpl.mdx"
import { RocketOutlined, ThunderboltOutlined, FundViewOutlined } from "@ant-design/icons";
import Link from "@docusaurus/Link";

<Row 
    title="Get Started" 
    description="Quick dive into the methodology"
    to="/docs/get-started"
    Icon={"🚀"}
    tags={['Basics','QuickStart','Motivation']}
/>
<Row 
    title="Guides" 
    description="Practical guides and application examples"
    to="/docs/guides"
    Icon={"🎯"}
    tags={['From v1','From legacy','Examples']}
/>
<Row 
    title="Concepts" 
    description="Core concepts for better understanding and application"
    to="/docs/concepts"
    Icon={"🧩"}
    tags={['Decomposition','Isolation','Public API']}
/>
<Row 
    title="About" 
    description="The philosophy of methodology, its goals and place in the modern frontend"
    to="/docs/about"
    Icon={"🍰"}
    tags={['Mission','Promote & Integration']}
/>
<Row 
    title="Community" 
    description="Community resources, additional materials"
    to="/docs/community"
    Icon={"💫"}
    tags={['Awesome','Team', 'Contributing']}
/>
<Row 
    title="Examples" 
    description="Examples of projects built with Feature Sliced"
    to="/examples"
    Icon={"🛠"}
/>

[refs-getstarted]: /docs/get-started
[refs-basics]: /docs/get-started/basics
[refs-motivation]: /docs/about/motivation
[refs-motivation-why]: /docs/about/motivation#why-are-there-not-enough-existing-solutions

[refs-concepts]: /docs/concepts
[refs-splitting]: /docs/concepts/app-splitting
[refs-splitting--layers]: /docs/concepts/app-splitting#group-layers
[refs-arch-req]: /docs/concepts/architecture#requirements
[refs-arch-problems]: /docs/concepts/architecture#problems

[refs-guides]: /docs/guides
[refs-low-coupling]: /docs/concepts/low-coupling
[refs-migration-v1]: /docs/guides/migration/from-v1
[refs-examples]: /docs/guides/examples

[refs-reference]: /docs/reference
[refs-module]: /docs/reference/glossary#module
[refs-knowledge]: /docs/about/knowledge-types

[refs-about]: /docs/about


[ext-ubiq-lang]: https://thedomaindrivendesign.io/developing-the-ubiquitous-language


