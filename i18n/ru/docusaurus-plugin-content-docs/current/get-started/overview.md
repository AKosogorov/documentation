---
sidebar_position: 1
---

# Основы {#basics}

:::caution Предупреждение

Здесь представлена лишь основная информация по методологии

Для более грамотного применения, стоит ознакомится детальней с каждым понятием в соответствующем разделе документации

:::


## Подходит ли это мне? {#is-it-right-for-me}

FSD подходит для проектов и команд любого размера с некоторыми оговорками:

- Эта методология исключительно для фронтенда. Если вы ищете архитектуру для бэкенда, обратите внимание на [Clean Architecture][refs-clean-architecture].
- Если вы разрабатываете очень простое приложение из одной странички на FSD, преимущества методологии вряд ли понадобятся, а вот разработка может замедлиться. Однако, FSD помогает стандартизированно мыслить о фронтенд-приложениях, так что смело используйте даже на маленьких проектах, если знаете, для чего она вам.
- Огромное приложение, соизмеримое с админ-панелью Google Cloud, потребует специализированной архитектуры. FSD в данном случае может выступать в качестве отправной точки.

Методология не привязана к конкретному языку программирования, UI-фреймворку или менеджеру состояния — подойдет любой (см. [примеры использования][refs-examples]).

Если у вас уже есть проект, не переживайте — FSD можно внедрять постепенно. Главный вопрос, который стоит задать команде: "**Eсть ли боль** при разработке проекта?" Если боли нет, возможно, переход делать не стоит. 


## Основы {#basics}

Проект на FSD состоит из <mark>слоев</mark> (layers), каждый слой состоит из <mark>слайсов</mark> (slices) и каждый слайс состоит из <mark>слайсов</mark> (segments).

![themed--scheme](/img/visual_schema.jpg)

Слои стандартизированы во всех проектах и расположены вертикально. Модули на одном слое могут взаимодействовать лишь с модулями, находящимися на слоях строго ниже. На данный момент слоев семь (снизу вверх):

1. `shared` — переиспользуемый код, не имеющий отношения к специфике приложения/бизнеса.
    <small>(например, UIKit, libs, API)</small>
2. `entities` (сущности) — бизнес-сущности (например, User, Product или Order).
    <small>(например, User, Product, Order)</small>
3. `features` (фичи) — взаимодействия с пользователем, действия, которые несут бизнес-ценность для пользователя.
    <small>(например, SendComment, AddToCart, UsersSearch)</small>
4. `widgets` (виджеты) — композиционный слой для соединения сущностей и фич в самостоятельные блоки
    <small>(например, IssuesList, UserProfile)</small>.
5. `pages` (страницы) — композиционный слой для сборки полноценных страниц из сущностей, фич и виджетов.
6. `processes` — сложные сценарии, покрывающие несколько страниц.
    <small>(например, авторизация)</small>
7. `app` — настройки, стили и провайдеры для всего приложения.

Затем есть слайсы, разделяющие код по предметной области. Они группируют логически связанные модули, что облегчает навигацию по кодовой базе. Слайсы не могут использовать другие слайсы на том же слое, что обеспечивает высокий уровень [_связности_][refs-wiki-cohesion] (cohesion) при низком уровне [_связанности_][refs-wiki-coupling] (coupling).

В свою очередь, каждый слайс состоит из сегментов. Это маленькие модули, главная задача которых — разделить код внутри слайса по техническому назначению. Самые распространенные сегменты — `ui`, `model` (store, actions), `api` и `lib` (utils/hooks), но в вашем слайсе может не быть каких-то сегментов, могут быть другие, по вашему усмотрению.

:::note

В большинстве случаев [рекомендуется][ext-disc-api] располагать `api` и `config` только в shared-слое

:::

**Also, FSD have few core-concepts:**
- [Public API][refs-public-api] - each module must have a *declaration of its public API* at the top level - without access to internal structure of modules with isolation of implementation
- [Isolation][refs-isolation] (Low Coupling & High Cohesion) - the module should not *depend directly* on other modules of the same layer or overlying layers (to prevent implicit connections and side effects during development and refactoring)
- [Domain Driven][refs-needs-driven] - orientation *to the needs of the business and the user* with [app splitting][refs-splitting] by business domains

### [`Public API`][refs-public-api]

Каждый модуль должен иметь на верхнем уровне **декларацию своего публичного API**

- Для подключения в другие модули, без нужды обращаться к внутренней структуре данного модуля
- Для изоляции деталей реализации от модулей-потребителей
- Также Public API должен защищать интерфейс модуля после рефакторинга - во избежание непредвиденных последствий

### [`Isolation`][refs-isolation]

Модуль не должен **зависеть напрямую** от других модулей того же слоя или вышележаших слоев

- Концепция известна также как [Low Coupling & High Cohesion][refs-low-coupling] - для предотвращения неявных связей / сайд-эффектов при разработке и рефакторинге

### [`Needs driven`][refs-needs-driven]

Ориентирование **на потребности бизнеса и пользователя**

- Включает в себя также разбиение структуры по бизнес-доменам *(["слоям"][refs-splitting-layers] и ["слайсам"][refs-splitting-slices])*


## Пример {#example}

Рассмотрим приложение социальной сети.

* `app/` содержит настройку роутера, глобальные хранилища и стили.
* `processes/` содержит часть аутентификации, отвечающую за чтение/запись токенов аутентификации.
* `pages/` содержит компоненты роутов на каждую страницу в приложении, преимущественно композирующие, по возможности, без собственной логики.

В рамках этого приложения рассмотрим карточку поста в ленте новостей.

* `widgets/` содержит "собранную" карточку поста, с содержимым и интерактивными кнопками, в которые вшиты запросы к бэкенду.
* `features/` содержит всю интерактивность карточки (например, кнопку лайка) и логику обработки этой интерактивности.
* `entities/` содержит скелет карточки со слотами под интерактивные элементы. Компонент, демонстрирующий автора поста, также находится в этой папке, но в другом слайсе.

```sh
└── src/
    ├── app/                    # Layer: Приложение
    |                           #
    ├── processes/              # Layer: Процессы (опционально)
    |   ├── {some-process}/     #     Slice: (н-р процесс CartPayment)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (helpers/utils)
    |   |   └── model/          #         Segment: Бизнес-логика
    |   ...                     #
    ├── pages/                  # Layer: Страницы
    |   ├── {some-page}/        #     Slice: (н-р страница ProfilePage)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (helpers/utils)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    ├── widgets/                # Layer: Виджеты
    |   ├── {some-widget}/      #     Slice: (н-р виджет Header)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (helpers/utils)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    ├── features/               # Layer: Фичи
    |   ├── {some-feature}/     #     Slice: (н-р фича AuthByPhone)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (helpers/utils)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    ├── entities/               # Layer: Бизнес-сущности
    |   ├── {some-entity}/      #     Slice: (н-р сущность User)
    |   |   ├── lib/            #         Segment: Инфраструктурная-логика (helpers/utils)
    |   |   ├── model/          #         Segment: Бизнес-логика
    |   |   └── ui/             #         Segment: UI-логика
    |   ...                     #
    ├── shared/                 # Layer: Переиспользуемые ресурсы
    |   ├── api/                #         Segment: Логика запросов к API
    |   ├── config/             #         Segment: Конфигурация приложения
    |   ├── lib/                #         Segment: Инфраструктурная-логика приложения
    |   └── ui/                 #         Segment: UIKit приложения
    |   ...                     #
    └── index.tsx/              #
```

### Преимущества {#advantages}

- **Единообразие**  
  Код распределяется согласно области влияния (слой), предметной области (слайс) и техническому назначению (сегмент).  
  Благодаря этому архитектура стандартизируется и становится более простой для ознакомления.

- **Контролируемое переиспользование логики**  
  Каждый компонент архитектуры имеет свое назначение и предсказуемый список зависимостей.  
  Благодаря этому сохраняется баланс между соблюдением принципа **DRY** и возможностью адаптировать модуль под разные цели.

- **Устойчивость к изменениям и рефакторингу**  
  Один модуль не может использовать другой модуль, расположенный на том же слое или на слоях выше.
  Благодаря этому приложение можно изолированно модифицировать под новые требования без непредвиденных последствий.


## Постепенное внедрение {#incremental-adoption}

Сила FSD в _структурированной_ декомпозиции. В лучшей форме, FSD позволяет найти место для любой части кода почти однозначно. Однако, уровень декомпозиции — это параметр, и любая команда может подстроить его для оптимального баланса между легкостью внедрения и преимуществами.

Предлагаем следующую стратегию для миграции существующей кодовой базы на FSD, проверенную опытом:

1. Вырезать слои `app` и `shared`, чтобы иметь опору для последующих этапов. Эти слои получатся тонкими и простыми, пусть такими и остаются.

2. Вынести весь интерфейс, связанный с бизнесом, распределить по виджетам и страницам, даже если в них пока что будут зависимости, нарушающие правила FSD.

3. Постепенно наращивать степень декомпозиции, выделяя `features` и `entities`. Превращать страницы и виджеты из перегруженных логикой слоёв в чисто композиционные слои.

Рекомендуется воздержаться от добавления новых крупных сущностей во время рефакторинга, а также рефакторинга по частям.

## См. также {#see-also}

- [(Раздел) Фундаментальные концепции методологии][refs-concepts]
- [(Раздел) Гайды и примеры по применению методологии][refs-guides]
- [(Статья) Про разбиение логики в приложении. Модуляризация][refs-splitting]

[ext-disc-api]: https://github.com/feature-sliced/documentation/discussions/66

[refs-concepts]: /docs/concepts
[refs-public-api]: /docs/concepts/public-api
[refs-isolation]: /docs/concepts/cross-communication
[refs-needs-driven]: /docs/concepts/needs-driven

[refs-splitting]: /docs/concepts/app-splitting

[refs-guides]: /docs/guides
[refs-examples]: /examples
[refs-clean-architecture]: https://medium.com/codex/clean-architecture-for-dummies-df6561d42c94
