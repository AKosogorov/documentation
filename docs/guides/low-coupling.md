# Слабая зацепленность и сильная связность
Модули приложения должны проектироваться как обладающие сильной связностью (направленные на решение одной четкой задачи) и слабой зацепленностью (как можно менее зависимые от других модулей)

В рамках методологии это достигается через:

* Разбиение приложения на слои - области влияния и слайсы - модули, реализующие конкретную функциональность.
    Подробнее: [**Разбиение приложения**](../concepts/app-splitting.md)
* Требование к каждому модулю - предоставлять публичный интерфейс доступа.
    Подробнее: [**Публичное API модуля приложения**](../concepts/public-api.md)
* Введение специальных ограничений на взаимодействие модулей между собой - каждый модуль может зависеть только от "нижележащих" модулей, но не от модулей с того же или более высокого слоя.
    Подробнее: [**Взаимодействие модулей приложения**](../concepts/cross-communication.md)


## Как достичь слабой зацепленности

### В UI - композиция компонентов

Абсолютное большинство современных UI-фреймоворков и библиотек предоставляют компонентную модель, в которой каждый компонент может иметь собственные свойства, собственное состояние и дочерние компоненты, а также, зачастую, слоты. Такая модель позволяет собирать интерфейс как композицию различных, напрямую не связанных между собой компонентов и, тем самым, достигать слабой зацепленности компонентов интерфейса

Рассмотрим такую композицию на примере **списка с хедером:** 

1. Компонент списка не будет сам определять вид и структуру компонентов хедера и элементов списка, вместо этого будет принимать их в качестве параметров

```ts
interface ListProps {
    Header: Component;
    Items: Component;
}

const List: Component<ListProps> = ({ Header, Items }) => (
    <div class="wrapper">
        {Header}
        <ul class="...">
            {Items}
        </ul>
    </div>
)

```
2. Это позволяет переиспользовать и независимо изменять компоненты различных версий хедера и элементов списка. Компоненты хедера и элементов списка могут иметь как свое локальное состояние, так и свою привязку к любым частям общего состояния приложения - компонент списка не будет ничего про это знать, а следовательно, не будет от этого зависеть

```ts
<List Header={<FancyHeader />} Items={<ToDoItems />} />

<List Items={<CartItems />} />

<List Header={<FancyHeaderV2 color="red" />} Items={<FancyItems />} />

```
