# Слабая зацепленность и сильная связность
Модули приложения должны проектироваться как обладающие **сильной связностью** (направленные на решение одной четкой задачи) и **слабой зацепленностью** (как можно менее зависимые от других модулей)

В рамках методологии это достигается через:

* Разбиение приложения на слои - области влияния и слайсы - модули, реализующие конкретную функциональность.
    Подробнее: [**Разбиение приложения**](../concepts/app-splitting.md)
* Требование к каждому модулю - предоставлять публичный интерфейс доступа.
    Подробнее: [**Публичное API модуля приложения**](../concepts/public-api.md)
* Введение специальных ограничений на взаимодействие модулей между собой - каждый модуль может зависеть только от "нижележащих" модулей, но не от модулей с того же или более высокого слоя.
    Подробнее: [**Взаимодействие модулей приложения**](../concepts/cross-communication.md)


## Как достичь слабой зацепленности

### В UI - композиция компонентов

Абсолютное большинство современных UI-фреймоворков и библиотек предоставляют компонентную модель, в которой каждый компонент может иметь собственные свойства, собственное состояние и дочерние компоненты, а также, зачастую, слоты. Такая модель позволяет собирать интерфейс как **композицию различных, напрямую не связанных между собой компонентов** и, тем самым, достигать **слабой зацепленности** компонентов интерфейса

Рассмотрим такую композицию на примере **списка с хедером:** 

1. Компонент списка не будет сам определять вид и структуру компонентов хедера и элементов списка, вместо этого будет принимать их в качестве параметров

```ts
interface ListProps {
    Header: Component;
    Items: Component;
}

const List: Component<ListProps> = ({ Header, Items }) => (
    <div class="wrapper">
        {Header}
        <ul class="...">
            {Items}
        </ul>
    </div>
)

```
2. Это позволяет **переиспользовать и независимо изменять** компоненты различных версий хедера и элементов списка. Компоненты хедера и элементов списка могут иметь как свое локальное состояние, так и свою привязку к любым частям общего состояния приложения - компонент списка не будет ничего про это знать, а следовательно, не будет от этого зависеть

```ts
<List Header={<FancyHeader />} Items={<ToDoItems />} />

<List Items={<CartItems />} />

<List Header={<FancyHeaderV2 color="red" />} Items={<FancyItems />} />

```

### На уровне приложения - композиция фич и сущностей

Методология предлагает разделять ценную для пользователя функциональность на отдельные модули - [**фичи (features)**](../references/layers/feature.md), а логику, относящуюся к бизнес сущностям - в [**сущности (entities)**](../references/layers/entities.md). И фичи, и сущности **должны проектироваться как высоко-связные модули**, т.е. направленные на решение **одной конкретной задачи** или сконцентрированные вокруг **одной конкретной сущности.**

Все взаимодействия между такими модулями, аналогично UI-компонентам из примера выше, должны быть организованы как **композиция различных модулей.**

На примере приложения-чата с такими возможностями:

* можно открыть список контактов и выбрать друга
* можно открыть переписку с выбранным другом

В рамках методологии, это может быть представлено примерно так:

Сущности
* Пользователь (содержит состояние пользователя)
* Контакт (состояние списка контактов, инструменты для работы с отдельным контактом)
* Переписка (состояние текущей переписки и работа с ней)

Фичи
* Форма отправки сообщения
* Меню выбора переписки

1. Свяжем всё это вместе. В приложении, для начала, будет одна страница, интерфейс будет основан на слегка модифицированном компоненте из первого примера

```ts
// page/main/ui.tsx
<List
    Header={<ConversationSwitch />}
    Items={<Messages />}
    Footer={<MessageInput />}
/>
```

2. Модель данных страницы будет организована как **композиция фич и сущностей**

```ts
//pages/main/model.ts
import { userStore } from "entitites/user"
import { conversationStore } from "entities/conversation"
import { contactStore } from "entities/contact"

import { createMessageInput } from "features/message-input"
import { createConversationSwitch } from "features/conversation-switch"

export const { allConversations, setConversation } = createConversationSwitch({
    contacts: contactStore.allContacts,
    setConversation: conversationStore.setConversation,
    currentConversation: conversationStore.conversation,
    currentUser: userStore.currentUser
})

export const { sendMessage, attachFile } = createMessageInput({
    author: userStore.currentUser
    send: conversationStore.sendMessage
})
```
