[disc-src]: https://github.com/feature-sliced/wiki/discussions/31

[disc-list]: https://github.com/feature-sliced/wiki/discussions/
[disc-poll]: https://github.com/feature-sliced/wiki/discussions/31#discussioncomment-464894
[disc-api]: https://github.com/feature-sliced/wiki/discussions/66
[disc-processes]: https://github.com/feature-sliced/wiki/discussions/20
[disc-model]: https://github.com/feature-sliced/wiki/discussions/68
[disc-usability]: https://github.com/feature-sliced/wiki/discussions/65

[tg-description]: https://t.me/atomicdesign/18951

[ext-pluralsight]: https://www.pluralsight.com/guides/how-to-organize-your-react-+-redux-codebase
[ext-medium]: https://alexmngn.medium.com/why-react-developers-should-modularize-their-applications-d26d381854c1

# Разбиение приложения

> Про разбиение приложения согласно методологии

---

## Group: `Layers`

Первый уровень разделения: по **скоупу влияния** модуля

> **Самопроверка**: *"К какому слою приложения относится модуль?"*

```sh
└── src/
    ├── app/                    # Инициализирующая логика приложения
    ├── processes/              # (Опц.) Процессы приложения, протекающие над страницами
    ├── pages/                  # Страницы приложения
    ├── features/               # Ключевой функционал приложения (разбитый по фичам)
    ├── entities/               # Бизнес-сущности
    └── shared/                 # Переиспользуемые модули
```

### Порядок слоев

Если посмотреть на порядок слоев - то можно выделить две закономерности:

#### По уровню знания/ответственности

> `app > *processes > ... > entities > shared`

Модуль "знает" только про себя и нижележащие модули, но не выше лежащие

*Это же влияет и на разрешенные импорты*

#### По уровню опасности изменений

> `shared > entities > ... > *processes > app`

Чем ниже расположен модуль - тем опаснее вносить в него изменения

*Т.к. скорее всего он заиспользован во многих вышележащих слоях*

## Group: `Slices`

Второй уровень разделения: по **конкретной функциональности БЛ**

*Методология не влияет на этот уровень и все крайне зависит [от конкретного проекта][disc-usability]*

> **Самопроверка**: *"Какую область БЛ затрагивает модуль?"*
>
> *До этого - надо определится со скоупом влияния (layer)*

```sh
├── app/
|   # Не имеет конкретных слайсов, 
|   # т.к. там содержится логика инициализации всего проекта
├── processes/
|   # Слайсы для реализации процессов на страницах
|   ├── order
|   ├── auth
|   └── ...
├── pages/
|   # Слайсы для реализации страниц приложения
|   ├── profile
|   ├── sign-up
|   ├── feed
|   └── ...
├── features/
|   # Слайсы для реализации конкретной функциональности на страницах
|   ├── auth-by-phone
|   ├── inline-post
|   └── ...
├── entities/
|   # Слайсы бизнес-сущностей для реализации более сложной БЛ
|   ├── viewer
|   ├── posts
|   ├── i18n
|   └── ...
└── shared/
    # Сам по себе представляет слайс, 
    # т.к. здесь только переиспользуемые модули, без привязки к БЛ
```

## Group: `Segments`

Третий уровень разделения: по **назначению модуля в коде и реализации**

> **Самопроверка**: *"Какую часть тех. реализации логики затрагивает модуль?"*
>
> *До этого - надо определится со скоупом влияния (слой) и доменной принадлежностью (слайсом)*

```sh
{layer}/
    ├── {slice}/
    |   ├── ui/                     # UI-логика (components, ui-widgets, ...)
    |   ├── model/                  # Бизнес-логика (store, actions, effects, reducers, ...)
    |   ├── lib/                    # Инфраструктурная логика (utils/helpers)
    |   ├── config*/                 # Конфигурация (проекта / слайса)
    |   └── api*/                    # Логика запросов к API (api instances, requests, ...)
```

*При этом, каждый сегмент может быть представлен **как в виде файла, так и в виде отдельной директории** - в зависимости от сложности и размеров*

### Ограничения

Методология разрабатывалась с целью - не ограничивать и не утруждать разработчиков правилами выбора абстракций *(хотелось, чтобы **любой из сегментов можно было использовать в любом слое**)*

Однако в результате [дискуссий и анализа обширного опыта][disc-list] - было определено, что лучше и практичнее **ограничить каждый слой на используемые внутри сегменты**.

#### Общие правила

- (\*) Чем **выше расположен** слой - тем больше он знает про БЛ приложения и наоборот
- (\*\*) API логику [рекомендуется][disc-api] класть в `shared`, чтобы логика не распылялась по проекту
    > Как правило - она общая и представлена в виде единых инстансов
    >
    > **Edge-case "exceptions"**: *GraphQL*, *react-query hooks*

#### Применение для слоев

1. `app`: не включает в себя слайсы и содержит логику инициализации
    > Имеющиеся сегменты не совсем подходят, а потому используются обычно `/hocs`, `/styles` и т.д.
    >
    > Очень зависит от проекта и вряд ли решается методологией
2. `processes`: слайсы внутри включают в себя только бизнес-логику, без отображения (\*)
    > Разрешенные сегменты: `lib`, `model`, `**api`
3. `pages`: слайсы внутри включают в себя ui- и model- композицию различных фичей для конкретной страницы
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
4. `features`: слайсы внутри включают в себя композицию сущностей и реализацию БЛ в модели + отображение
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
5. `entities`: слайсы внутри представляют разрозненный набор подмодулей для использования
    > Разрешенные сегменты: `ui`, `lib`, `model`, `**api`
6. `shared`: содержат только инфраструктурную логику без БЛ \*)
    > Разрешенные сегменты: `ui`, `lib`, `api`

## См. также

- [(Обсуждение) Абстракции методологии, их цели и нейминг][disc-src]
- Обсуждения по неймингу сущностей
  - [Опрос по неймингу][disc-poll]
  - [`processes` vs `flows` vs ...][disc-processes]
  - [`model` vs `store` vs ...][disc-model]
- [Первичное описание абстракций][tg-description]
- [(Статья) Про организацию кодовой базы *с полным сравнением нескольких подходов*][ext-pluralsight]
- [(Статья) Про модуляризацию проектов][ext-medium]
